**Ryan Goss**

**Homework 01** | 24 Jan 2018

Software Development 5828

1. **Define the term **** essential difficulties **** as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.**

Books defines _ess__ential difficulties_ as the _inherent properties_ that make building software hard—and he uses the term &quot;hard&quot; relative to building hardware where he makes the argument that software is _orders of magnitude_ more difficult to build properly and without mistakes. This means that software is _defined by_ the problems that Books points out (complexity, conformity, changeability and invisibility) by the way software is engineered, and due to this very nature and what software is doing and solving, it will always carry these problems. For example, software projects are complex by nature, meaning by the way they operate and the billions of different states and cases they must deal with makes them much more difficult to &quot;assemble&quot; than any hardware counterpart. No two &quot;parts&quot; (or functions) are alike, unlike in hardware where the number of parts are much less in software. Additionally, each of the &quot;parts&quot; in software interact in nonlinear ways, resulting in a complexity growth that is exponential.

1. **Define the term **** accidental difficulties **** as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.**

These are difficulties that, unlike _essential difficulties_, have unnecessarily been introduced into the piece of software or the software process by human design (error). Brooks gives the example of high level programming languages solving an _accidental difficulty_. This is because while the high level language are taking previously complex constructs that a lower level language (say, assembly) dealt with and reducing it to more simplified constructs, those more complex bits that assembly had created were, in essence, needless in the first place. The essence of the piece of software would still be _essentially difficult_ by its very nature and way it operates—the high level language is just attempting to get closer to approximating or reducing the delta between _accidental difficulty_ and _essential difficulty_.

1. **List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.**

As stated in (1), the essential difficulties are broken down into the categories of _complexity_, _conformity_, _changeability_ and _invisibility_, where the former three are really just subcategories of the first.

While _complexity_ was defined in (1) with the &quot;parts&quot; example (each part is dissimilar and heterogeneous), a more concrete example of this could be thought of building a Lamborghini vs. an operating system. While the Lamborghini is, no doubt, extremely complex to engineer and build precisely, the number of states to account for are much more manageable and predictable, as we know all the functions we want it to be able to accomplish and the build list is well defined. For an operating system, all of the states are not as easily visualized or accounted for. In fact, it is impossible to even predict all of them as the number and types of parts is enormous, and their interactions with each other unique, causing the complexity to be exponentially higher.

_Conformity_ is defined by the underlying fact that software will always need to be made to &quot;fit&quot; into some situation or ecosystem that carry certain constrains—I like to think of it like the &quot;real world&quot; vs. the &quot;perfect world&quot;. When you build a piece of software, it will need to interact with pre-existing infrastructure. Like when building web-based programs—while we would love to assume everyone has ultra-fast internet, a 4k screen, the latest version of Java installed and the best hardware possible, that just isn&#39;t a real-world assumption and you wont reach all of your users. So, we have to build software in a less than ideal structure or an unknown structure making it that much more complex to account for and build properly.

Software is also made more complex by the fact that it is more &quot;ethereal&quot; or, put more simply, _changeable_. Because software consists merely of some blocks of text, many perceive it to be easy to change, and that all changes are equally as easy. Of course many other factors can influence this from regulations, to product recalls, to business and marketing needs. Generally though, the culture around software pushes rapid change and the fact that it is a malleable product dramatically increases its _essential difficulty_.

Finally, software is made difficult by _invisibility_, meaning it is difficult to conceptualize in concrete or true terms. For example, we often try to model software by drawing architecture diagrams or conceptualizing functions with visuals but none of these are truly capturing the reality of software (as they are ultimately just models/abstractions). Functions in software operate this way, unseen, while a motor in a car can be directly observed, making it much more _visible_. So, we must operate on the basis of a conceptualized framework of software, as it will always be _essentially__invisible_.

1. **Define what Brooks means by a **** silver bullet **** and reconstruct his argument as to why he believes there is no silver bullet for software engineering.**

By _silver bullet,_ Brooks means there is no one and single advance that has or will dramatically reduce (and by dramatically an order of magnitude) software creation difficulty. He lays out a number of current and predicted technological advances that are purported to reduce difficulty but in examining each of them, they are to likely only reduce _accidental difficulty_, not _essential difficulty_.  These technologies would bring us closer to approximating a software&#39;s essential difficulty but they would not remove it. For example, artificial intelligence has been claimed to dramatically reduce complexity, and while it will likely reduce accidental difficulty by further abstracting more difficult or granular tasks, like high level programming languages it won&#39;t take away the essential complexity of a program. Nor will visual programming, because as we discussed in (4), a visual of a piece of software is just an abstraction and it does not visualize the actuality of what a piece of software is—and the essence that software will never be something physical that can be visualized. These, along with many other examples are given to show that there is no single (or even multiple) technologic, cultural or organizational breakthrough that will suddenly solve or dramatically reduce the _essential difficulties_.

1. **In lecture, software engineering&#39;s relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.**

Software engineering can be thought of more as the practical application of computer science to the constraints of the real world, including ensuring it works consistently across multiple platforms, user varieties and that it is scalable. Similar to the chemist vs. chemical engineer metaphor, we can think of computer scientists researching and discovering the cutting edge science—learning what is currently possible through experimentation and research. Chemists may invent a new way to synthesize a new drug, for example and a computer scientist may invent a new algorithm or speech recognition methodology. Both, however, were done once, on a small scale and may still be only theoretical. An chemical engineer would be responsible for taking the methodology and technique that the chemist had invented and engineering a large scale process to see if it is reproducible, saleable and reliable (bringing it from theoretical to the real world). This would be just the same for a software engineer, who would look for the newly invented speech recognition algorithm and figuring out how/if it can be implemented into a real-world application that the masses could use.

1. **In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.**

Software engineers use _abstractions_ by practice. These mean using a made up term or definition to represent something. This is an attempt to simplify or make something theoretical or hard to conceptualize, more concrete. Classes, data structures and variables are an example of this, as they are a construct to abstract a theoretical concept into something easier to understand as we can name it and think about it more concretely (by mapping it out for example).

Software is constantly driven by _specification_. Without it, we don&#39;t have any idea of what we are actually making. So, design, requirements, tests, plans and timelines all have specific specifications that are followed, which form the blueprint of the product. Without good specification, we can&#39;t produce a well made product.

Software is also a process of constant _translation_. We are taking requirements or the description of what we want the software to do and translating it to code, an abstraction of this mental construct that we have formed. We also constantly translate between languages to make a program cross platform, or to talk with other APIs. In this way, good software engineers need to be adept and translation.

Software also involves constant _iteration_, meaning a constant refactoring and reworking. We often think of this in an agile process but due to software&#39;s constant changeability we constantly iterate to produce the final product—and even the final product is not final. Iteration allows us to start with a concept or a base and continually build on it with testing and rethinking to &quot;polish&quot; to a better product.

Finally, software development ultimately depends on people, which means any good software development involves constant _conversation_. This means that all those involved, from those that make the requirements, to the architect to the coders to the debuggers, everyone needs to communicate with each other very well and constantly. This way, the common vision for the piece of software can come together in a unified way and represents the shared vision of the group.